[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python y librerías Geoespaciales para el análisis de datos en el contexto de los Incendios Forestales",
    "section": "",
    "text": "Descripción\n¡Bienvenid@os al taller teórico-práctico “Python y Librerías Geoespaciales para el análisis de datos en el contexto de los Incendios Forestales”!\nEste taller ha sido diseñado para proporcionarles las herramientas y conocimientos necesarios para abordar, de manera práctica y efectiva, el análisis de datos geoespaciales con el lenguaje de programación Python. A lo largo del taller, exploraremos un conjunto de librerías especializadas y software que nos permitirán realizar una serie de tareas que involucran el preprocesamiento, procesamientos y análisis sobre los datos espaciales con un enfoque particular en los Incendios Forestales.\nNuestro objetivo es capacitar a los participantes para manejar, procesar y visualizar datos geoespaciales que contribuyan al entendimiento y prevención de los Incendios Forestales, una problemática relevante y desafiante para el medio ambiente y las comunidades. Este taller forma parte del proyecto Fondecyt de Iniciación 11231083.\n¡Esperamos que este taller sea una experiencia enriquecedora, donde teoría y práctica se fusionen para potenciar sus habilidades y conocimientos en el ámbito del análisis geoespacial aplicado a desafíos ambientales contemporáneos!\nEste libro digital fue hecho usando Quarto. Puede revisar su documentación dentro del siguiente link.",
    "crumbs": [
      "Descripción"
    ]
  },
  {
    "objectID": "01-python-librerias.html",
    "href": "01-python-librerias.html",
    "title": "1  Introducción a Python y Librerías esenciales",
    "section": "",
    "text": "1.1 Programas necesarios\nPara poder organizar nuestro entorno de trabajo, deberemos descargar algunos programas que ayudarán a generar ambientes de trabajo reproducibles y aislados entre sí.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Python y Librerías esenciales</span>"
    ]
  },
  {
    "objectID": "01-python-librerias.html#programas-necesarios",
    "href": "01-python-librerias.html#programas-necesarios",
    "title": "1  Introducción a Python y Librerías esenciales",
    "section": "",
    "text": "Git Bash\nBash es un intérprete de línea de comandos y un lenguaje de scripting muy popular en sistemas operativos Unix y basados en Unix, como Linux y macOS. A través de esta se puede controlar el computador digitando los comandos desde el teclado, en lugar de usar los botones y menús como habitualmente se hace con los sistemas operativos más usados.\nDe forma nativa, este intérprete no se encuentra dentro de Windows, por lo que, para hacer uso de este deberemos descargar Git Bash, el cual integra esta herramiento junto con git, “un sistema de control de versiones distribuido, libre y de código abierto, diseñado para manejar proyectos de cualquier tamaño, desde pequeños hasta muy grandes, con rapidez y eficiencia”.\n\n\n\n\n\n\nNota\n\n\n\nSi bien, Git no suena tan familiar, su versión online GitHub si. Esta página alberga código y sus versiones en internet y cualquier persona puede ser capaz de ver, replicar y alterar dicho (con los permisos suficientes). Algunas de las empresas que ocupan esto son Google, Microsoft y Netflix.\n\n\nPara su instalación, nos dirigiremos a la página oficial de Git Bash:\n\nhttps://git-scm.com/downloads\n\nSeleccionamos el sistema operativo y versión (64-bit y 32-bit) que corresponda al computador. Ejecutamos el instalador, al terminar se verá similar a la imagen a continuación, los colores pueden cambiar, ya que ofrece la posibilidad de personalizar.\n\n\n\n\n\n\nFigura 1.1: Git Bash abierto en el escritorio, muestra el usuario (Alene), el computador (LAPTOP-RLJ48LRB) y la ruta en la barra principal (/c/Users/Alene).\n\n\n\n\n\nMiniconda\nPara la creación de entornos de trabajo podemos ocupar Conda, un sistema de gestión de paquetes y entornos de desarrollo, facilitando la instalación y gestión de librerías con sus dependencias, siendo importantes para evitar incompatibilidades entre paquetes. Debido a que Anaconda resulta tener un gran volumen, ocuparemos Miniconda, la cual es una distribución de Python que posee lo esencial para funcionar. Dentro de este instalaremos los paquetes y librerías que necesitamos para realizar los análisis geoespaciales.\nEl instalador se encuentra disponible en:\n\nhttps://docs.conda.io/en/latest/miniconda.html\n\n\n\n\n\n\n\nImportante\n\n\n\nEs IMPORTANTE seleccionar el sistema operativo y versión (64-bit y 32-bit) que corresponda al computador y durante la instalación seleccione la primera opción para “Agregar Miniconda3 a mi variable de entorno PATH” seleccionando también en “Registrar Anaconda como Python 3.x predeterminado”.\n\n\nAunque el paso de agregar Anaconda al PATH no es recomendado por el sistema, lo haremos igualmente para que sea más fácil usar Conda con Git Bash.\n\nProbando la nueva configuración\n\nCerramos y abrimos el Bash.\nEn el Terminal que se levanta digite bash y presione Enter. Si no se obtiene ningún mensaje, quiere decir que Bash está disponible para ser utilizado.\nDigite git y presione Enter. Si aprecia una serie de comandos, Git está disponible para ser utilizado.\n\n\n\n\n\n\n\nFigura 1.2: Git Bash testeado con bash (sin mensaje) y git (comandos disponibles).\n\n\n\n\nDigite conda y presiona Enter, si se aprecia una serie de comandos, Conda está disponible para ser empleado.\n\n\n\n\n\n\n\nFigura 1.3: Conda testeado en Git Bash.\n\n\n\n\n\n\nEl ambiente\nDentro Conda instalaremos un ambiente de Python con librerías específicas para el análisis de datos geoespaciales que sido creado exclusivamente para este taller. Puedes descargar el archivo del ambiente haciendo clic aquí.\n\n\n\n\n\n\nAdvertencia\n\n\n\nTodavía hay que ver esto. EL NOMBRE NO ES TALLERPYTHON, SINO QUE SPYDER-PYTHON una cosa asi, insertar al final\n\n\nEste archivo (de extensión .yml) contiene todos los paquetes con sus dependencias necesarios para desarrollar las actividades posteriores. Dentro de él se encuentra el nombre del ambiente (en este caso tallerpython), las librerías y los canales desde donde se obtienen.\n\n\n\n\n\n\nNota\n\n\n\nNote que aquí estamos creando un ambiente con paquetes previamente definidos. Si desea crear otro ambiente, con otras librerías, puede consultar la guía de conda.\n\n\nPara instalar este ambiente ejecute desde el Terminal el comando conda env create -f tallerpython.yml.\n\n\n\n\n\n\nImportante\n\n\n\nTenga en cuenta que el proceso toma tiempo y varía de acuerdo con las capacidades de cada computador.\n\n\n\n\n\n\n\n\nFigura 1.4: Instalación del entorno con el archivo environment.yml.\n\n\n\nPara ver la lista de los entornos de trabajo disponibles, ejecute conda info --envs. En este caso, nos interesa el ambiente tallerpython.\n\n\n\n\n\n\nFigura 1.5: Ambientes instalados. Se pueden observar varios ya instalados.\n\n\n\nPara activar cualquier entorno de trabajo debe ejecutar conda activate &lt;nombre-entorno&gt;.\nEn el caso de que Git Bash genere problemas al usar conda activate ejecute conda init bash solo una vez. Posteriormente, reinicie Git Bash para que los cambios surtan efecto. Si el problema persiste, puede intentar revisando el siguiente link.\nPara desactivar el entorno de trabajo conda deactivate, como se observa a continuación, pasamos del ambiente base al recién instalado y luego a base nuevamente.\n\n\n\n\n\n\nFigura 1.6: Activación y desactivación de los entornos.\n\n\n\n\n\nSpyder\nSpyder es un entorno de desarrollo integrado (IDE) de código abierto diseñado específicamente para la programación en Python. Combina herramientas avanzadas en un solo lugar, lo que lo hace popular entre investigadores y analistas.\nSpyder ya viene en el entorno de trabajo. Para usarlo solo hay que escribir spyder estando en el entorno tallerpython.\nDentro de este, deberemos escoger el sistema operativo del computador.\n\nPartes de Spyder\nSpyder cuenta principalmente con 3 paneles, los cuales pueden tener distintas funcionalidades. Entre sus partes principales se encuentran:\n\nEditor\n\nEn este panel se encuentra el script de Python a ejecutar. Dentro de este, se nos mostrará advertencias (warnings) o errores dentro de nuestro código. Por defecto, las líneas se encuentran numeradas. También se pueden agregar pequeñas anotaciones para destacar ciertas líneas de código (pequeños puntos rojos en líneas 25 y 29).\n\n\n\n\n\n\nFigura 1.7: Editor de Spyder\n\n\n\n\nConsola\nAquí es donde se ejecuta el código. Una manera de hacerlo es dentro del Editor y apretando F5 o Ctrl + Enter. En el caso de querer ejecutar código en solo una línea o líneas seleccionadas, puede apretar F9. También puede ejecutar código directamente en la consola.\n\n\n\n\n\n\nFigura 1.8: Consola de Spyder\n\n\n\n2.1. Historial\nSe muestra el historial del código ejecutado. También aparece código de sesiones anteriores.\n\n\n\n\n\n\nFigura 1.9: Historial de Spyder\n\n\n\nConjunto de Sub-Paneles\nEste panel contiene distintas herramientas que aportarán interacción al análisis de los datos geográficos.\n3.1. Explorador de variables\nSe muestran los objetos creados con la posibilidad de interactuar con estos.\n\n\n\n\n\n\nFigura 1.10: Explorador de variables en Spyder\n\n\n\n3.2. Gráficos\nMuestra todos los gráficos ejecutados en la sesión.\n\n\n\n\n\n\nFigura 1.11: Gráficos dentro de Spyder\n\n\n\n3.3. Ayuda\nA través de Ctrl + I, Spyder es capaz de mostrar la documentación de la función en la que se está.\n\n\n\n\n\n\nFigura 1.12: Ayuda dentro de Spyder\n\n\n\n3.4. Perfilador\nEl perfilador determina el tiempo de ejecución y el número de llamadas para cada función y método llamado en un archivo. Esto te permite identificar fácilmente los cuellos de botella en tu código, señala declaraciones exactas más críticas para la optimización y mide la diferencia de rendimiento después de los cambios de seguimiento.\n\n\n\n\n\n\n\nFigura 1.13: Perfilador (Profiler) dentro de Spyder",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Python y Librerías esenciales</span>"
    ]
  },
  {
    "objectID": "01-python-librerias.html#recordatorio",
    "href": "01-python-librerias.html#recordatorio",
    "title": "1  Introducción a Python y Librerías esenciales",
    "section": "Recordatorio",
    "text": "Recordatorio\nVamos a realizar un repaso para ver que todo está en orden. Para esto se ejecutará un script dentro de Spyder. A continuación, explicaremos un ejemplo de carga y visualización de datos. Este tendrá los siguientes pasos:\n\nCarga de librerías.\nCambio en el directorio de trabajo.\nCarga de datos.\nVisualización de datos.\n\n\nLibrerías\nLas librerías o paquetes son una forma de organizar múltiples funciones relacionadas. Estan se componen de módulos, los cuales son archivos individuales que contienen código reutilizable. Acceder a esta (y para ocupar Python en general) se ocupa la notación de punto (Dot notation). Aquí, el nombre del objeto va seguido de un punto (.), y luego el nombre del atributo o método al que se quiera acceder o invocar.\n\n\nDirectorios de trabajo\nAl escribir un script de Python es importante saber en que ruta estás dentro del computador. Esto con el fin de poder acceder correctamente a datos que se necesiten ocupar, exportar resultados, entre otros. En Python, puedes utilizar el módulo os para gestionar rutas, ya que evita errores relacionados con rutas relativas o absolutas.\n\n\nCarga de datos\nEn nuestro contexto de análisis geoespacial, las principales herramientas que nos ayudarán a cargar datos son Pandas, GeoPandas y Rasterio, ya que sirven para datos tabulares, vectoriales y raster, respectivamente.\n\n\nVisualización de datos\nLa principal herramienta para visualizar datos dentro de Python es Matplotlib, el cual a través de su módulo pyplot, permite generar desde simples a complejas figuras. En el caso particular de los datos raster, el paquete earthpy otorga las herramientas necesarias para generar representaciones adecuadas para este tipo de datos.\n\n\nEjemplo\nUna vez explicado los pasos a seguir, se tiene que implementar en código. Este tendrá la siguiente forma:\n\n1import os\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\n2os.chdir(\"D:/Descargas\")\n\n3poligono = gpd.read_file(\"polygon.shp\")\n\n4fig, ax = plt.subplots()\n\npoligono.plot(ax = ax,\n              color = \"red\")\n\nax.set_title(\"Polígono a visualizar\")\n\nplt.show()\n\n\n1\n\nImporta las librerías necesarias. Tanto geopandas como matplotlib.pyplot están abreviados gracias a as. La abreviación existe para facilitar la escritura dentro del script.\n\n2\n\nCambia el directorio de trabajo a la ruta D:/Descargas. Esta ruta es personal y varía según dispositivo.\n\n3\n\nCon GeoPandas (gpd) carga un archivo vectorial (.shp).\n\n4\n\nA través de Matplotlib (plt), graficamos el objeto poligono. Si desea más información de como visualizar datos, consulte su documentación.\n\n\n\n\nSi todo va bien, el resultado del script sería la figura mostrada abajo:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Python y Librerías esenciales</span>"
    ]
  },
  {
    "objectID": "01-python-librerias.html#ejercicios",
    "href": "01-python-librerias.html#ejercicios",
    "title": "1  Introducción a Python y Librerías esenciales",
    "section": "1.2 Ejercicios",
    "text": "1.2 Ejercicios\n\nDescargue y lea los datos vectoriales disponibles en este enlace. Estos datos corresponden a una base de datos histórica de cicatrices de fuego en Chile (propiedad del (CR)2 y disponibles en el siguiente link). Una vez descargados, visualizarlos.\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nEl paquete earthpy tiene un submódulo especializado para descargar datos desde internet. Este es data.get_data().\n\n\n\n\nUna vez cargados los datos, a través de sus atributos, consulte por la cantidad de puntos de ignición y superficie quemada por región.\nDadas las provincias de Chile continental (disponibles en el siguiente enlace), consulte la cantidad de puntos de ignición que existen por región, usando una consulta basada en la coincidencia espacial. Observe si hay diferencias con lo obtenido con el ejercicio anterior.\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nEn el caso de que las capas estén en otro sistema de referencia, puede ocupar la función de GeoPandas .to_crs().\nGeoPandas permite disolver polígonos a través de .dissolve(). Si tiene dudas, puede consultar la documentación de ambas funciones.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Python y Librerías esenciales</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html",
    "href": "02-geomatica.html",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "",
    "text": "2.1 Datos vectoriales\nLos datos vectoriales están compuestos de posiciones geométricas discretas (valores x,y), conocidos como vértices, que definen la forma del objeto espacial. La organización de los vértices determina el tipo de vector con el que se está trabajando, existiendo tres tipos de datos, los puntos, las líneas y los polígonos. Entre los formatos más utilizados se encuentra el shapefile (.shp) o el GeoJSON (.geojson).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#datos-raster",
    "href": "02-geomatica.html#datos-raster",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "2.2 Datos Raster",
    "text": "2.2 Datos Raster\nLos rásters o cuadrículas son datos almacenados en una matriz de valores, representados como píxeles. Cada valor de píxel representa un área específica de la superficie terrestre, formando así el dato espacial. Un archivo ráster está compuesto por una cuadrícula regular de celdas de igual tamaño. Probablemente ya hemos utilizado datos ráster, como en fotografías digitales o imágenes de Google Earth. Sin embargo, los rásters que vamos a trabajar son distintos de las fotografías comunes, ya que están espacialmente referenciados. Esto significa que cada píxel representa una porción concreta de la superficie terrestre, lo cual se conoce como resolución espacial.\nLos datos ráster pueden tener una o varias capas (también llamadas layers o variables). Por ejemplo, un modelo de elevación generalmente incluye solo una capa que representa la altitud de la superficie terrestre en un área determinada. Sin embargo, otros tipos de datos, como imágenes multiespectrales o series temporales, pueden producir un ráster compuesto por varias capas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#sistemas-de-referencia",
    "href": "02-geomatica.html#sistemas-de-referencia",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "2.3 Sistemas de referencia",
    "text": "2.3 Sistemas de referencia\nEs muy común que se obtengan datos espaciales desde distintas fuentes y que esos datos cubran diferentes extensiones espaciales. Este tipo de datos espaciales se encuentran a menudo en diferentes Sistemas de Referencia de Coordenadas (CRS, por sus siglas en inglés). En el caso de que se quiera trabajar con datos en distints CRS deberemos reproyectarlos. Sin embargo, es importante mencionar que cuando reproyectamos los datos, los estamos modificando. De esta forma estamos introduciendo alguna incerteza en nuestros datos. Mientras que esta incerteza es ligeramente menos importante en los datos vectoriales que en los raster, es necesario considerarla. Por otra parte, si solo se reproyecta para crear un mapa base, no es importante.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#formación-del-color",
    "href": "02-geomatica.html#formación-del-color",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "2.4 Formación del color",
    "text": "2.4 Formación del color\nLa teoría aditiva del color explica cómo se forma el color mediante la combinación de luces de diferentes colores, especialmente los colores primarios de la luz: rojo, verde y azul (RGB). Cuando estos colores de luz se mezclan en diversas intensidades, generan una gama completa de colores.\n\n\n\n\n\n\nFigura 2.1: Composición RGB\n\n\n\nEn un monitor de computadora, cada píxel está compuesto por subpíxeles rojo, verde y azul. Al ajustar la intensidad de cada subpíxel, el monitor produce diferentes colores visibles.\nEn las imágenes de satélite, esta teoría se aplica para representar las bandas espectrales. Cada banda (p. ej., visible, infrarrojo) se asigna a un canal de color (R, G, B) para crear una composición de color que permite observar características específicas de la superficie terrestre.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#tipos-de-imágenes",
    "href": "02-geomatica.html#tipos-de-imágenes",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "2.5 Tipos de imágenes",
    "text": "2.5 Tipos de imágenes\nAnteriormente ya mencionamos que existen diferentes tipos de imágenes, desde aquellas que almacenan solo una variable, hasta las que contienen varias o cientos.\n\nMonobanda\nSon aquellas que solo almacenan una variable o layer. Es común encontrar este tipo de imágenes para almacenar y representar datos de tipo continuo, como la temperatura superficial o la reflectancia. No obstante, se usan también para representar variables de tipo discretas como las categorías de un sistema de clasificación.\n\n\n\n\n\n\n\n\n\n\n\nMultiespectral\nLas imágenes multiespectrales son raster que poseen datos en varias bandas del espectro electromagnético. Cada banda representa una parte diferente del espectro, por ejemplo, visible, infrarrojo cercano, infrarrojo medio, etc. Las bandas son herramientas analíticas de la superficie terrestre. Por ejemplo, la imagen de un satélite multiespectral tiene bandas para:\n\nLuz visible (rojo, verde, azul [RGB])\nInfrarrojo cercano (NIR)\nInfrarrojo medio (MIR)\nOtras\n\nEstas bandas se pueden combinar con los colores RGB que proporcionan los monitores para obtener distintas composiciones que resaltan características específicas, como la vegetación o el agua.\n\n\n\n\n\n\n\n\n\nComposición Color Natural\n\n\n\n\n\n\n\n\n\nComposición Falso Color",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#plataformas-y-fuentes-de-datos-satelitales",
    "href": "02-geomatica.html#plataformas-y-fuentes-de-datos-satelitales",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "2.6 Plataformas y fuentes de datos satelitales",
    "text": "2.6 Plataformas y fuentes de datos satelitales\nExisten diversas plataformas y fuentes de datos satelitales que proporcionan imágenes y datos geoespaciales para una amplia variedad de aplicaciones.\n\nTerra - Aqua- MODIS\nMODIS es el Moderate-Resolution Imaging Spectroradiometer abordo de satélites Terra y Aqua de la NASA. Es capaz de capturar 36 bandas espectrales con una resolución espacial desde 250 metros a 1 kilómetro. Es ampliamente ocupado debido a su alta resolución temporal (nivel diario).\n\n\n\n\n\n\nFigura 2.2: Bandas de MODIS.\n\n\n\n\n\nLandsat - OLI\nOLI es Operational Land Imager, a bordo de los últimos satélites Landsat. El programa Landsat son una seria de misiones satelitales gestionadas por la NASA y el Servicio Geológico de Estados Unidos (USGS). Desde 1972 han proporcionado imágenes multiespectrales de mediana resolución (30 metros), y continuamente están lanzando nuevos satélites. El último ha sido Landsat 9, que fue lanzado el 2021 mejorando la calidad y adquisición de las imágenes de su antecesor (Landsat 8).\n\n\n\n\n\n\nFigura 2.3: Bandas de Landsat.\n\n\n\n\n\nSentinel - MSI\nMSI es el Multiespectral Imager a bordo de los satelitales Sentinel-2. Estos forman parte del programa comandado por la Agencia Espacial Europea (ESA), lanzando distintas misiones llamadas Sentinel. Al igual que Landsat, proporciona imágenes de mediana-alta resolución para el monitoreo del Medio Ambiente. El último lanzamiento fue en 2015, el cual consta de dos satélites, Sentinel-2A y Sentinel-2B, capturando 13 bandas y una resolución que varía desde los 10 a 60 metros.\n\n\n\n\n\n\nFigura 2.4: Bandas de Sentinel.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#dentro-de-python",
    "href": "02-geomatica.html#dentro-de-python",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "2.7 Dentro de Python",
    "text": "2.7 Dentro de Python\nEn Python las librerías principales para poder trabajar con datos raster son rasterio y earthpy. rasterio es una librería de Python diseñada para leer y escribir datos raster geoespaciales, mientras que earthpy facilita el manejo de multiples tipos de datos, lidiando con su descarga, descompresión y visualización.\nPor ejemplo, se cargará e imprimirá la información de un raster de elevación (DEM)\n\n# Importando los paquetes necesarios\nimport os\nimport rasterio as rio\nimport earthpy.plot as ep\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nwith rio.open(\"pre_DTM.tif\") as src:\n    num_bandas = src.count\n    elcrs = src.crs\n    print(f\"La imagen tiene {num_bandas} bandas.\")\n    print(f\"La imagen tiene {elcrs}.\")\n    DEM = src.read(1, masked = True)\n\nLa imagen tiene 1 bandas.\nLa imagen tiene EPSG:32613.\n\n\nA través de earthpy podemos visualizarlo:\n\nf, ax = plt.subplots()\n\nep.plot_bands(DEM,\n              scale = False,\n              cmap = 'Greys',\n              title = \"Modelo Digital de Elevación\",\n              ax = ax)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "02-geomatica.html#ejercicios",
    "href": "02-geomatica.html#ejercicios",
    "title": "2  Fundamentos de Geomática y visualización de Datos Raster",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nCargar y visualizar el siguiente Modelo de Elevación Digital.\nDe la misma manera, descargue la imagen Sentinel y visualice cada banda que posea.\nDe acuerdo con la teoría del color, visualice varias composiciones que representen distintas características de la imagen. Puede usar la siguiente página para orientarse.\nDescargue esta imagen y visualice la composición, observe los histogramas de sus bandas.\n\nObservar sus histogramas.\nAplicar un realce lineal\nRealizar un recorte de la imagen con las coordenadas que se listan abajo:\n\n\nxmin = 697030.5734\nxmax = 700721.5109\nymin = 5494727.9939\nymax = 5496852.5981\n\n\nAplicar un realce lineal y observar sus histogramas.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nEl paquete earthpy posee distintas opciones para graficar las bandas, (ep.plot_bands), composiciones (et.plot_rgb) e histogramas (et.hist) de una imagen.\nAdicionalmente, rasterio tiene una función para poder realizar cortes a un raster (rio.clip_box).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de Geomática y visualización de Datos Raster</span>"
    ]
  },
  {
    "objectID": "03-imagenes.html",
    "href": "03-imagenes.html",
    "title": "3  Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios",
    "section": "",
    "text": "3.1 Índices de Vegetación de Banda Ancha\nLos IVs de banda ancha (los que se aplican a los sensores que poseen bandas espectrales anchas) se encuentran entre las estimaciones más simples de la cantidad y el vigor de la vegetación verde. Son combinaciones de las mediciones de reflectancia que son sensibles a los efectos combinados de la concentración de clorofila del follaje, el área foliar del dosel, la aglomeración del follaje y la arquitectura del dosel.\nLos IVs de banda ancha comparan las mediciones de reflectancia desde el pico de reflectancia de la vegetación en el rango del infrarrojo cercano (NIR) con otra medición tomada en el rango rojo (R), donde la clorofila absorbe fotones para almacenar energía a través de la fotosíntesis. El uso de mediciones del NIR, con una profundidad de penetración mucho mayor a través del dosel que el rojo, permite sondear la cantidad total de vegetación verde en la columna hasta que la señal se satura a niveles muy altos.\nDebido a que estas características son espectralmente amplias, muchos de los IVs de banda ancha pueden funcionar de manera efectiva con datos de imágenes recopilados de sensores multiespectrales como AVHRR, TM, OLI y MSI, entre otros.\nLas aplicaciones incluyen estudios de fenología (crecimiento) de la vegetación, evaluaciones del impacto climatológico y del uso de la tierra, y modelado de la productividad de la vegetación.\nLos aumentos en la concentración de clorofila de la hoja o el área de la hoja, la disminución de la aglomeración del follaje y los cambios en la arquitectura del dosel pueden contribuir a la disminución de las longitudes de onda R y al aumento de las longitudes de onda NIR, lo que provoca un aumento en los valores de verdor.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios</span>"
    ]
  },
  {
    "objectID": "03-imagenes.html#índices-de-vegetación-de-banda-ancha",
    "href": "03-imagenes.html#índices-de-vegetación-de-banda-ancha",
    "title": "3  Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios",
    "section": "",
    "text": "Figura 3.2: Reflectancia de las longitudes de onda.\n\n\n\n\n\n\n\nNormalized Difference Vegetation Index (NDVI)\nEste índice es una estimación de la vegetación verde y saludable. La combinación de su formulación de diferencia normalizada y el uso de las regiones de clorofila de mayor absorción y reflectancia lo hacen robusto en una amplia gama de condiciones (Figura 3.3). Sin embargo, puede saturarse en condiciones de vegetación densa cuando el LAI aumenta.\nEl valor de este índice varía de -1 a 1. El rango común para la vegetación verde es de 0,2 a 0,8. \\[\nNDVI=\\frac{(NIR-RED)}{(NIR+RED)}\n\\tag{3.1}\\]\nDonde:\n\nNIR corresponde al Infrarrojo Cercano\nRED a la longitud de onda visible para el rojo.\n\n\n\n\n\n\n\nFigura 3.3: Ejemplo del cálculo del NDVI para vegetación en distintas condiciones.\n\n\n\n\n\nNormalized Burn Ratio (NBR)\nEste índice estima el nivel de daño o severidad del fuego. Esto permite entre otras cosas, dimensionar las zonas afectadas, planificar y monitorear la restauración de los ecosistemas o recursos forestales afectados. La formulación del índice es muy similar al NDVI con la diferencia que usa el SWIR (banda sensible al contenido de humedad) en lugar del Red. \\[\nNBR=\\frac{(NIR-SWIR)}{(NIR+SWIR)}\n\\tag{3.2}\\]\nEl NBR mostrará un rango de valores que se encuentran entre -1 y 1. En este caso, los valores negativos se asociarán con zonas afectadas por el fuego o suelos descubiertos, mientras que altos valores positivos mostrarán vegetación que no se encuentra afectada por un incendio, o zonas de recuperación de incendios pasados, las áreas no quemadas tendrán valores cercanos a cero.\n\n\n\n\n\n\nFigura 3.4: Composición RGB y NBR de un incendio.\n\n\n\nA pesar que el NBR funciona relativamente bien para la estimación de severidad usando imágenes post-incendio, puede presentar confusiones con zonas de baja reflectancia. En este caso, es habitual el uso de índices que incorporen el componente temporal.\n\n\nDifference Normalized Burn Ratio (dNBR)\nEl dNBR funciona con una imagen previa y una posterior al incendio, sobre las cuales se calcula el NBR respectivo.\n\\[\ndNBR=(NBR_{pre} - NBR_{post}) \\times 100\n\\tag{3.3}\\]\nDe esta forma el dNBR permite estimar el grado de severidad de una zona, respecto a una condición anterior al incendio. Para generar las diferentes categorías de daño se suelen usar umbrales de corte del índice. Los umbrales indicados a continuación son los empleados por el US Forest.\n\n\n\nTabla 3.1: Categorías de severidad del dNBR según el US Forest\n\n\n\n\n\nNivel de Severidad\nRango dNBR\n\n\n\n\nRegeneración alta\n-500 a -251\n\n\nRegeneración baja\n-250 a -101\n\n\nNo quemado\n-100 a 99\n\n\nSeveridad baja\n100 a 269\n\n\nSeveridad media-baja\n270 a 439\n\n\nSeveridad media-alta\n440 a 659\n\n\nSeveridad alta\n660 a 1300\n\n\n\n\n\n\nEl desempeño de los índices o transformaciones espectrales se ve afectado por las condiciones de la vegetación, que pueden incluir a la heterogeneidad, estructura o cobertura. En otras palabras, no todas las transformaciones espectrales funcionan adecuadamente en todos los ecosistemas. Para el caso del dNBR, se ha reportado que subestima el nivel de daño, sobre todo cuando la vegetación pre-incendio corresponde a estructuras heterogéneas o se cuenta con poca cobertura. Para intentar mitigar estos efectos se pueden usar variaciones del dNBR.\n\n\n3.1.1 Relative difference Normalized Burn Ratio (RdNBR)\nEl RdNBR utiliza una pequeña modificación para evitar que exista correlación entre las condiciones previas al incendio y el valor de severidad que se estima. De esta manera minimiza los errores de clasificación para las áreas de mayor severidad, mantiene el significado de la severidad y permitiría la comparación de incendios históricos. \\[\nRdNBR=\\frac{dNBR}{\\sqrt{|\\frac{NBR_{pre}}{1000}}|}\n\\tag{3.4}\\]\n\n\n3.1.2 Relativized Burn Ratio (RBR)\nA pesar que el RdNBR es una mejora, no está exento de inconvenientes que pueden resultar en valores particularmente altos difíciles de interpretar, valores infinitos o ambiguos. Se propuso entonces el RBR como un índice que sea sensible a las condiciones de la vegetación pre incendio, pero que evite además los problemas del RdNBR.\n\\[\nRBR=\\left(\\frac{dNBR}{NBR_{pre}+1.001}\\right)\n\\]\n\n\n3.1.3 Burn Area Index (BAI)\nEste índice realza las áreas quemadas en la zona del NIR, enfatizando la señal del carbón en las imágenes post-incendio. Se calcula como una distancia espectral desde cada pixel a un punto espectral de referencia, donde suelen converger las áreas quemadas recientes.\n\\[\nBAI=\\frac{1}{(0.1-Red)^2+(0.06-NIR)^2}\n\\]\n\n\n3.1.4 Ejemplo\nEn el Módulo 2 aprendimos a cargar un raster en Python utilizando Rasterio. Es importante recordar que una imagen raster puede ser interpretada como una matriz, la cual NumPy puede manejar como un array. En el caso de una imagen monobanda, esta se representará como una matriz de \\(n\\) filas por \\(n\\) columnas. Por otro lado, una imagen multiespectral estará compuesta por múltiples matrices apiladas.\nUna vez cargado el raster, se pueden separar sus capas (bandas) y poder realizar las transformaciones espectrales. En el siguiente ejemplo, se cargará una imagen de Valdivia y se le calculará el NDVI:\n\n# Importación de librerías\nimport os\nimport rasterio as rio\nimport earthpy.plot as ep\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Cargamos la imagen\nwith rio.open(\"valdiviaSentinel.tif\") as src:\n    valdivia = src.read()\n    transform = src.transform\n    crsValdivia = src.crs\n\n# Seleccion de bandas (el conteo de bandas comienza desde 0)\nNIR = valdivia[8,:,:] # Banda 8a (NIR)\n\nRed = valdivia[3,:,:] # Banda 4 (Red)\n\n# NDVI\nNDVI = (NIR - Red)/(NIR + Red)\n\n# Visualizacion\nf, ax = plt.subplots()\nep.plot_bands(NDVI,\n              cmap = \"RdYlGn\",\n              vmin = -1,\n              vmax = 1,\n              ax = ax)\nax.set_title(\"NDVI en Valdivia\")\nplt.show()\n\n\n\n\nListado 3.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios</span>"
    ]
  },
  {
    "objectID": "03-imagenes.html#discretización-de-datos-raster",
    "href": "03-imagenes.html#discretización-de-datos-raster",
    "title": "3  Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios",
    "section": "3.2 Discretización de datos Raster",
    "text": "3.2 Discretización de datos Raster\nLos índices entregan valores continuos en un rango determinado, no obstante, para obtener las categorías de interés, es necesario encontrar ciertos valores o umbrales que permitan esa separación. Generalmente esos umbrales vienen dados o se pueden establecer desde calibraciones en campo o con gráficos de distribución de los valores.\nEn este caso, se mostrará una segmentación simple del NDVI anteriormente calculado. En este, valores mayores a 0.5 serán una categoría, mientras que valores menores o iguales 0.5 será otra categoría.\n\n# Creamos una copia de la variable original\nndvi_clases = NDVI.copy()\n\n# Re-clasifica los valores de los píxeles comparando con el NDVI original\nndvi_clases[np.where((NDVI &gt; 0.5))] = 2\nndvi_clases[np.where((NDVI &lt;= 0.5))] = 1\n\n# Visualizacion\nf, ax = plt.subplots()\nep.plot_bands(ndvi_clases,\n              cmap=\"RdYlGn\",\n              ax = ax)\n\nax.set_title(\"NDVI con dos clases\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios</span>"
    ]
  },
  {
    "objectID": "03-imagenes.html#vectorización-de-datos-raster",
    "href": "03-imagenes.html#vectorización-de-datos-raster",
    "title": "3  Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios",
    "section": "3.3 Vectorización de Datos Raster",
    "text": "3.3 Vectorización de Datos Raster\nCuando se han obtenido las categorías de interés, muchas veces es necesario transformar los objetos resultantes a formato vectorial para poder utilizarlos en conjunto con bases de datos ya existentes. Para obtener esto, primero deberemos cargar librerías extras. Posteriormente debemos seleccionar que pixeles son los que deseamos vectorizar, y así crear una máscara. Una vez creada la máscara, a través de shapely se transformará el raster a un objeto de tipo generator.\n\n\n\n\n\n\nNota\n\n\n\nNote que en el código del Listado 3.1 se crea la variable transform, el cual define cómo convertir entre las coordenadas de píxeles (índices de filas y columnas) y las coordenadas del sistema de referencia espacial del raster (generalmente coordenadas geográficas o proyectadas, como UTM).\nNote también que se le extrae el sistema de coordenadas del raster.\n\n\nUna vez hecho teniendo el objeto de tipo generator, se transformará a un GeoDataFrame el cual servirá para su visualización:\n\n#Importancion de librerias\nimport shapely # Nos permite transformar geometrías.\nimport rasterio.features as features # Contiene una función para vectorizar.\nimport geopandas as gpd\n\n# Asignamos mascara con pixeles de valor 2 (pixeles con mayor a 0.5 de NDVI) \nmask = ndvi_clases == 2\n\n# Convertirmos a objeto tipo generador\nresult = features.shapes(ndvi_clases, \n                transform = transform, \n                connectivity = 4, \n                mask = mask)\n\n# Convertimos result a geoDataFrame a través de un loop\nlista = []\n\n# Bucle que toma cada geometría y la agrega a la lista.\nfor x in result: \n    lista.append(shapely.geometry.shape(x[0]))\n\nlista_geo = gpd.GeoDataFrame(geometry = lista,\n                             crs = crsValdivia)\n\n# Visualizacion\nf, ax = plt.subplots()\nlista_geo.plot(ax = ax,\n               color = \"green\")\nax.set_title(\"NDVI vectorial en Valdivia\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios</span>"
    ]
  },
  {
    "objectID": "03-imagenes.html#exportación-de-archivos",
    "href": "03-imagenes.html#exportación-de-archivos",
    "title": "3  Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios",
    "section": "3.4 Exportación de archivos",
    "text": "3.4 Exportación de archivos\nUna vez creados los archivos de interés (ya sea raster o vectorial), podemos exportarlos de la siguiente manera:\nPara datos raster:\n\n# Para raster con el NDVI calculado =========\n\nwith rio.open(\"ndviValdivia.tif\", # Crea el archivo\n              'w', # En modo escritura (write)\n              driver = 'GTiff',  # Especifica el controlador (formato) del archivo, en este caso GeoTIFF\n              height = NDVI.shape[0], # Alto de raster\n              width = NDVI.shape[1], # Ancho de raster\n              count = 1, # Número de bandas en el raster \n              crs = crs, # Sistema de referencia de coordenadas (CRS) del raster\n              transform = transform, # Transformación de afinidad del raster\n              dtype = \"float32\") as dst: # Tipo de dato de los valores del raster\n    dst.write(NDVI, 1)\n\n# Para el raster con las clases del NDVI =========\nwith rio.open(\"ndvi_clases.tif\", # Crea el archivo\n              'w', # En modo escritura (write)\n              driver = 'GTiff',  # Especifica el controlador (formato) del archivo, en este caso GeoTIFF\n              height = ndvi_clases.shape[0], # Alto de raster\n              width = ndvi_clases.shape[1], # Ancho de raster\n              count = 1, # Número de bandas en el raster \n              crs = crs, # Sistema de referencia de coordenadas (CRS) del raster\n              transform = transform, # Transformación de afinidad del raster\n              dtype = \"float32\") as dst: # Tipo de dato de los valores del raster\n    dst.write(ndvi_clases, 1)\n\nPara datos vectoriales:\n\nlista_geo.to_file(\"ndvi_vectrorial.shp\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios</span>"
    ]
  },
  {
    "objectID": "03-imagenes.html#ejercicios",
    "href": "03-imagenes.html#ejercicios",
    "title": "3  Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nDescargue el siguiente set de datos. Ests son dos imágenes Sentinel de Viña del Mar antes y después de los incendios ocurridos en Febrero de este año. Las bandas entregadas son: B1, B2, B3, B4, B5, B6, B7, B8, B8a, B9, B11, B12.\nA través de Rasterio y NumPy calcule NDVI y BAI para la imagen post-incendio.\nCalcule el NBR y los derivados de este índice para ambas imágenes.\nA través de la Tabla 3.1, discretice el raster de dNBR y exportelo como un archivo .tif.\nVectorice el raster discretizado y exportelo como archivo .shp.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Procesamiento de Imágenes Satelitales para el Monitoreo de Incendios</span>"
    ]
  },
  {
    "objectID": "04-analisisTemporal.html",
    "href": "04-analisisTemporal.html",
    "title": "4  Análisis Temporal y Estadística Zonal",
    "section": "",
    "text": "4.1 Introducción\nLa estadística zonal es una técnica utilizada en los Sistemas de Información Geográfica (GIS) para analizar las propiedades de los valores de un raster dentro de zonas específicas definidas por otro raster o capa vectorial. Este método implica el cálculo de estadísticas descriptivas (como la media, la mediana, el máximo, el mínimo, la desviación estándar, etc.) para los valores de los píxeles que caen dentro de cada zona. Las zonas son definidas normalmente por atributos como regiones administrativas, tipos de hábitat, categorías de uso del suelo, entre otros.\nLa importancia de la estadística zonal en GIS radica en su capacidad para proporcionar información detallada y contextual sobre áreas específicas, permitiendo análisis espaciales más precisos y fundamentados. Algunos ejemplos de su aplicación incluyen:\nLa estadística zonal es una herramienta poderosa que facilita el análisis espacial detallado y contextualizado, apoyando la toma de decisiones informada en una amplia gama de campos.\nEn este caso, en el NDVI obtenido en el Módulo 3, calcularemos los principales estadígrafos (media, desviación estándar, mínimo, máximo y mediana) a distintos sitios dentro de la zona. Si quiere seguir el esta demostración puedeo obtener los datos en el siguiente enlace.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Temporal y Estadística Zonal</span>"
    ]
  },
  {
    "objectID": "04-analisisTemporal.html#introducción",
    "href": "04-analisisTemporal.html#introducción",
    "title": "4  Análisis Temporal y Estadística Zonal",
    "section": "",
    "text": "Estudios Ambientales: en un análisis de la calidad del aire, se podrían utilizar estadísticas zonales para calcular la concentración media de contaminantes en diferentes zonas urbanas, ayudando a identificar áreas con niveles de contaminación críticos.\nPlanificación Urbana y Regional: puede utilizarse para evaluar la densidad de población o el uso del suelo en diferentes barrios o distritos, lo que es crucial para la toma de decisiones en cuanto a infraestructura, servicios y regulaciones de zonificación.\nAgricultura y Gestión de Recursos Naturales: pueden aplicarse para analizar variables como la humedad del suelo, los rendimientos de los cultivos o la topografía en diferentes parcelas, lo que ayuda en la gestión de recursos y la toma de decisiones agrícolas.\nEstudios de Biodiversidad y Conservación: se pueden usar para evaluar la distribución de especies o la cobertura de hábitat en diferentes áreas protegidas o ecosistemas.\nGestión de Desastres y Respuesta de Emergencia: permite analizar el impacto de eventos como inundaciones, incendios forestales o terremotos en diferentes zonas, lo que es esencial para la planificación de la respuesta de emergencia y la rehabilitación.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Temporal y Estadística Zonal</span>"
    ]
  },
  {
    "objectID": "04-analisisTemporal.html#dentro-de-python",
    "href": "04-analisisTemporal.html#dentro-de-python",
    "title": "4  Análisis Temporal y Estadística Zonal",
    "section": "4.2 Dentro de Python",
    "text": "4.2 Dentro de Python\n\n\n\nCódigo\n# Importacion de librerias\nimport os\nimport pandas as pd\nimport rasterio as rio\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport earthpy.plot as ep\nimport geopandas as gpd\nimport rioxarray as rxr\n\n# Carga de sitios (puntos)\npuntosAOI = gpd.read_file(\"puntosVal.shp\")\n\n# Cargamos nuestro raster a traves de rioxarray (para mantener atributos del raster)\nvaldiNdvi = rxr.open_rasterio(\"ndviValdivia.tif\")\n\n# Visualizacion\nf, ax = plt.subplots(figsize = (10, 8))\n\nvaldiNdvi.plot(ax = ax, \n           cmap = 'RdYlGn', \n           vmin = -1, \n           vmax = 1)\n\npuntosAOI.plot(ax = ax,\n            color = \"blue\",\n            marker = \"*\",\n            markersize = 10)\n\nfor i in range(len(puntosAOI)):\n    ax.annotate(puntosAOI[\"id\"].iloc[i],\n                (puntosAOI.geometry.x[i] - 380, puntosAOI.geometry.y[i] - 300))\n\nax.set_title(\"NDVI en Valdivia sitios de interés\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nNote que los sitios de interés son elementos vectoriales de tipo punto, por lo que, con ellos no es posible obtener los estadígrafos (ya que solo contienen un valor). Para arreglar esto, crearemos un área buffer de 250 metros.\n\n# Copiamos los puntos para crear las areas buffer\npuntosBuffer = puntosAOI.copy()\n\n# Reemplazamos la geometria original (de puntos) por la calculada (buffer)\npuntosBuffer['geometry'] = puntosBuffer.geometry.buffer(distance = 250)\n\n\n\n\n\n\n\nNota\n\n\n\n\n\nLa delimitación del tamaño del área buffer depende del CRS de sus capas. En este caso, debido a que las capas se encuentran en el EPSG:32718, el sistema de medida a ocupar será en metros.\n\n\n\nAsí se ven las zonas buffer creadas a partir de los puntos\n\n\n\nCódigo\nf, ax = plt.subplots(figsize = (10, 8))\n\nvaldiNdvi.plot(ax = ax, \n           cmap = 'RdYlGn', \n           vmin = -1, \n           vmax = 1)\n\npuntosBuffer.plot(ax = ax,\n            edgecolor = \"blue\",\n            facecolor = \"none\",\n            hatch = \"////\")\n\nax.set_title(\"NDVI en Valdivia con buffers de interés\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nUna vez creado el buffer, se extraen los valores desde el raster y se calcula los estadísticos de interes.\n\n# Lista vacia\nestadisticas = []\n\n# For loop para extraccion\nfor x in range(len(puntosBuffer)):\n    \n    # Se extrae el nombre del sitio\n    idFila = puntosBuffer[\"id\"].iloc[x]\n\n    # Selección de la geometria\n    geometriaFila = puntosBuffer.iloc[[x]].geometry \n    \n    # Recorte\n    parcelaPix = valdiNdvi.rio.clip(geometriaFila) \n    \n    # Aplanamos los valores a un array de una sola dimension\n    parcelaValores = parcelaPix.values.flatten()\n    \n    # Sacamos los NaN\n    valores = parcelaValores[~ np.isnan(parcelaValores)]\n    \n    # Se calculan los estadigrafos\n    media = np.mean(valores)\n    mediana = np.median(valores)\n    sd = np.std(valores)\n    minimo = np.min(valores)\n    maximo = np.max(valores)\n    \n    # Se agregan a la lista anteriormente creada\n    estadisticas.append({\n        'id': idFila,\n        'media': media,\n        'mediana': mediana,\n        'sd': sd,\n        'minimo': minimo,\n        'maximo': maximo\n    })\n    \n# Convertimos en un DataFrame\nestadisticas = pd.DataFrame(estadisticas)\n\n# Unimos nuestro gdf de buffer con el de estadisticas\npuntosBuffer = puntosBuffer.merge(estadisticas,\n                                  how = \"inner\")\n\npuntosBuffer\n\n\n\n\n\n\n\n\nid\ngeometry\nmedia\nmediana\nsd\nminimo\nmaximo\n\n\n\n\n0\nSitio 1\nPOLYGON ((653575.211 5589444.45, 653574.007 55...\n0.167249\n0.158344\n0.131650\n-0.200989\n0.847045\n\n\n1\nSitio 2\nPOLYGON ((657751.113 5587109.038, 657749.909 5...\n0.884141\n0.888256\n0.030674\n0.764588\n0.955374\n\n\n2\nSitio 3\nPOLYGON ((647863.596 5587432.921, 647862.392 5...\n-0.533523\n-0.520000\n0.105754\n-0.865546\n-0.235294\n\n\n3\nSitio 4\nPOLYGON ((653486.052 5594718.46, 653484.848 55...\n0.467598\n0.431419\n0.160849\n0.199051\n0.933968\n\n\n4\nSitio 5\nPOLYGON ((650214.474 5593885.099, 650213.27 55...\n0.753121\n0.780255\n0.081850\n0.382153\n0.872004\n\n\n5\nSitio 6\nPOLYGON ((648314.848 5591447.791, 648313.644 5...\n0.542913\n0.563952\n0.108113\n-0.037657\n0.771179\n\n\n6\nSitio 7\nPOLYGON ((656519.267 5591356.813, 656518.064 5...\n0.884160\n0.886569\n0.031950\n0.768481\n0.973029\n\n\n\n\n\n\n\nFinalmente podemos visualizar nuestro resultado.\n\n\n\nCódigo\nfig, ax = plt.subplots(figsize=(10, 8))\n\nvaldiNdvi.plot(ax = ax, \n               cmap = 'RdYlGn', \n               vmin = -1, \n               vmax = 1)\n# Etiquetas\nfor i in range(len(puntosBuffer)):\n    # Nombre\n    ax.annotate(puntosBuffer[\"id\"].iloc[i],\n                (puntosAOI.geometry.x[i] - 380, puntosAOI.geometry.y[i] - 550))\n    \n    # Media\n    ax.annotate(round(puntosBuffer[\"media\"].iloc[i], 3),\n                (puntosAOI.geometry.x[i] - 380, puntosAOI.geometry.y[i]- 900))\n\n# Buffer\npuntosBuffer.plot(ax = ax,\n            edgecolor = \"blue\",\n            facecolor = \"none\",\n            hatch = \"////\")\n\nax.set_title(\"Media de NDVI en cada buffer\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nfig, ax = plt.subplots()\n\nax.scatter(x = puntosBuffer[\"id\"],\n           y = puntosBuffer[\"media\"])\n\nax.errorbar(\n    x = puntosBuffer[\"id\"],\n    y = puntosBuffer[\"media\"],\n    yerr = puntosBuffer[\"sd\"],  # Barra de error ± 1 desviación estándar\n    fmt = 'o',  # Marcador para los puntos\n    ecolor = 'gray',  # Color de las barras de error\n    capsize = 4)       # Tamaño de las líneas en los extremos de la barra\n\nax.set_title(\"Media ± SD para cada sitio\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Temporal y Estadística Zonal</span>"
    ]
  },
  {
    "objectID": "04-analisisTemporal.html#ejercicios",
    "href": "04-analisisTemporal.html#ejercicios",
    "title": "4  Análisis Temporal y Estadística Zonal",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nObtenga un gráfico de caja y bigotes (boxplot) para cada sitio.\nCon el siguiente set de datos obtenga el NDVI promedio para el fundo El Desprecio. Este fundo … . Los datos consisten en 9 imágenes Landsat desde septiembre de 2016 a septiembre 2017. Todas las imágenes tienen 4 bandas, (R, G, B y NIR).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Temporal y Estadística Zonal</span>"
    ]
  },
  {
    "objectID": "05-modelado.html",
    "href": "05-modelado.html",
    "title": "5  Modelado y Predicción del Comportamiento de Incendios",
    "section": "",
    "text": "5.1 Preparación de datos\nAntes de comenzar, tendremos que cargar algunas librerías extras:\nimport os\nimport pandas as pd\nimport geopandas as gpd\nimport numpy as np\nimport rasterio as rio\n1import rioxarray as rxr\nimport matplotlib.pyplot as plt\n\n2from sklearn.model_selection import train_test_split\n3from sklearn.ensemble import RandomForestRegressor\n4from sklearn.metrics import roc_auc_score\n\n\n1\n\nrioxarray es una librería que combina capacidades de manejar datos multidimensionales con las capacidades de rasterio.\n\n2\n\nsklearn es una de las librerías más ocupadas dentro de Python para el Machine Learning. En esta línea se está importando una función que facilita la extracción de puntos para muestras y las de validación.\n\n3\n\nDel submódulo ensemble se ocupa Random Forest Regressor el cual, puede predecir valores continuos.\n\n4\n\nPor útltimo, el submódulo metrics importa la función AUC que servirá para evaluar el rendimiento del modelo.\nUna vez cargada las librerías, llamaremos a los datos. Estos se componen de puntos para ignición/no-ignición. Ambos servirán para el entrenamiento del modelo. Además del raster multibanda que alberga a las variables predictoras.\nLo primero es verificar que nuestros datos se encuentren en el mismo CRS:\ncoord_1 = gpd.read_file(\"puntos/si_ignicion_2016.shp\") # Muestras igncion\ncoord_0 = gpd.read_file(\"puntos/no_ignicion_2016.shp\") # Muestras no ignicion\n\n# Imprimimos los atributos del raster\nwith rio.open('datos/datos_2016.tif') as src:\n    crsRaster = src.crs\n    print(f\"El crs de los datos es {src.crs}\\n\"\n          f\"La cantidad de bandas (datos) es {src.count}\")\n\ndatos_raster = rio.open('datos/datos_2016.tif') \n\nEl crs de los datos es EPSG:32718\nLa cantidad de bandas (datos) es 5\nif coord_1.crs == coord_0.crs == crsRaster:\n    print(\"Todas las capas se encuentran en el mismo CRS\")\nelse:\n    print(f\"coord1: {coord_1.crs}\\n\"\n          f\"coord2: {coord_2.crs}\\n\"\n          f\"raster:{datos_raster.crs}\")\n\nTodas las capas se encuentran en el mismo CRS\nA través de una función que vamos a construir, obtendremos los datos de las variables en el raster usando las coordenadas de los puntos. Posteriormente, ambas listas se convierten a DataFrame y se les asigna una etiqueta. Por último, se unen ambos DataFrames:\ndef ext_muestras(gdf_data, raster):\n    # Crear lista de coordenadas\n    coordenadas = []\n\n    # Extrae un punto con sus coordenadas\n    for punto in gdf_data.geometry:\n        coordenada = (punto.x, punto.y)\n        coordenadas.append(coordenada)\n    \n    # Crear lista de muestras\n    muestras = []\n\n    # Por cada muestra, extrae el valor del raster\n    for muestra in raster.sample(coordenadas):\n        muestras.append(muestra)\n        \n    return muestras\n\n# Aplicamos la funcion en ambos puntos (ignición y no ignición) y trasnforman a df\nmuestras_1 = ext_muestras(coord_1, datos_raster)\ndf_1 = pd.DataFrame(muestras_1)\ndf_1[\"etiqueta\"] = 1\n\nmuestras_0 = ext_muestras(coord_0, datos_raster)\ndf_0 = pd.DataFrame(muestras_0)\ndf_0[\"etiqueta\"] = 0\n\n# Concatenar primero los DataFrames\ndf = pd.concat([df_1, df_0])\n\ndf.head()\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\netiqueta\n\n\n\n\n0\n0.272334\n0.005340\n0.056346\n0.038409\n0.084056\n1\n\n\n1\n0.235562\n0.000916\n0.002559\n0.024636\n0.042263\n1\n\n\n2\n0.239623\n0.000000\n0.005721\n0.035887\n0.081381\n1\n\n\n3\n0.239623\n0.000000\n0.005721\n0.035887\n0.081381\n1\n\n\n4\n0.239853\n0.003663\n0.040057\n0.039573\n0.190806\n1\nPara ingresar los datos correctamente al algoritmo de Random Forest, debemos separar los datos en dos arrays. Uno conteniendo únicamente los valores de los datos y otro conteniendo las etiquetas para cada observación.\nX = df.drop('etiqueta', axis=1).to_numpy()\ny = df['etiqueta'].to_numpy()\n\nprint(f\"Array con valores \\n\"\n      f\"{X}\")\n\nprint(f\"Array con etiquetas\\n\"\n      f\" {y}\")\n\nArray con valores \n[[0.2723342  0.0053401  0.05634571 0.03840931 0.08405565]\n [0.23556209 0.00091582 0.00255853 0.02463628 0.04226349]\n [0.23962295 0.         0.00572104 0.03588749 0.08138058]\n ...\n [0.14969738 0.00259033 0.01718694 0.0399612  0.03792626]\n [0.13984863 0.00377602 0.0452288  0.08962173 0.2745725 ]\n [0.15907876 0.00091582 0.01412993 0.06188167 0.01227861]]\nArray con etiquetas\n [1 1 1 ... 0 0 0]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modelado y Predicción del Comportamiento de Incendios</span>"
    ]
  },
  {
    "objectID": "05-modelado.html#entrenamiento",
    "href": "05-modelado.html#entrenamiento",
    "title": "5  Modelado y Predicción del Comportamiento de Incendios",
    "section": "5.2 Entrenamiento",
    "text": "5.2 Entrenamiento\n\n# Particion de datos\n1trainX, testX, trainy, testy = train_test_split(X,\n                                                y,\n                                                test_size = 0.3,\n                                                shuffle = True)\n# Activar el modelo RandomForestRegressor\nmodelo_RF = RandomForestRegressor()\n\n# Entrena el modelo con los datos de entrenamiento\n2modelo_RF.fit(trainX, trainy)\n\n\n1\n\nLa función train_test_split divide los datos para porciones de entrenamiento y de test. Como input necesita el array con los valores de los datos (X), un array con las etiquetas (y), el tamaño de datos para la prueba (test_size) y establecer si mezclar los datos (shuffle). Como outputs se obtienen los conjuntos de entrenamiento y de test tanto de X como de y.\n\n2\n\nmodelo_RF.fit entrena el modelo utilizando los datos de entrenamiento. Durante este, el modelo aprende relaciones entre las características y las etiquetas en los datos de entrenamiento.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modelado y Predicción del Comportamiento de Incendios</span>"
    ]
  },
  {
    "objectID": "05-modelado.html#predicción-y-validación",
    "href": "05-modelado.html#predicción-y-validación",
    "title": "5  Modelado y Predicción del Comportamiento de Incendios",
    "section": "5.3 Predicción y validación",
    "text": "5.3 Predicción y validación\nPara predecir deberemos ocupar la función .predict:\n\n# Realizar predicciones con los datos de X\npredicciones = modelo_RF.predict(X = testX)\n\n# Obtiene AUC para la estimación del desempeño.\nmetrica = roc_auc_score(testy, predicciones)\n\nprint(f\"AUC: {metrica}\")\n\nAUC: 0.8616207951070336",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modelado y Predicción del Comportamiento de Incendios</span>"
    ]
  },
  {
    "objectID": "05-modelado.html#prediciendo-con-el-modelo",
    "href": "05-modelado.html#prediciendo-con-el-modelo",
    "title": "5  Modelado y Predicción del Comportamiento de Incendios",
    "section": "5.4 Prediciendo con el modelo",
    "text": "5.4 Prediciendo con el modelo\n\n1data = rxr.open_rasterio('datos/datos_2016.tif')\n\n2pixeles = data.values.transpose(1,2,0)\n\n3pixeles_t = pixeles.reshape(-1, 5)\n\n4pred_2016 = modelo_RF.predict(pixeles_t)\n\n5mapa_pred = pred_2016.reshape(pixeles.shape[0],\n                              pixeles.shape[1])\n\n6resultado = data[0].copy()\nresultado.values = mapa_pred\n\n\n1\n\nSe carga el mismo raster con los datos, excepto que ahora se hace con rioxarray.\n\n2\n\nTranspone los datos del raster para que las bandas estén en el último eje. En este caso pasa de una estructura (bandas, filas, columnas) a (filas, columnas, bandas).\n\n3\n\nReorganiza los datos en un array de 2 dimensiones. Aquí, el -1 permite que NumPy calcule automáticamente el tamaño de la primera dimensión, mientras que el 5 es el número de bandas.\n\n4\n\nOcupa el modelo entrenado para hacer las predicciones sobre los datos reorganizados.\n\n5\n\nSe reorganizan de nuevo las predicciones para obtener la forma original del raster.\n\n6\n\nSe crea una copia del raster original y asigna las predicciones a los valores del raster.\n\n\n\n\nPara observar el resultado del modelo podemos usar Matplotlib.\n\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\nresultado.plot(\n    ax = ax,\n    cmap = 'viridis',\n    add_colorbar = True,\n    cbar_kwargs = {'label': 'Probabilidad de ignición'})\n\ncoord_1.plot(\n    ax = ax,\n    color = 'red',\n    markersize= 15,\n    label = 'Ignición')\n\nax.set_title('Probabilidad de ignición año 2016')\nax.set_ylabel(\"\")\nax.set_xlabel(\"\")\n\n\nax.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modelado y Predicción del Comportamiento de Incendios</span>"
    ]
  }
]